# 27. Вывести маршрут максимальной стоимости
# Ограничение времени	1 секунда
# Ограничение памяти	256Mb
# Ввод	стандартный ввод или input.txt
# Вывод	стандартный вывод или output.txt
# В левом верхнем углу прямоугольной таблицы размером
# N
# ×
# M
#  находится черепашка. В каждой клетке таблицы записано некоторое число. Черепашка может перемещаться вправо или вниз, при этом маршрут черепашки заканчивается в правом нижнем углу таблицы.
# Подсчитаем сумму чисел, записанных в клетках, через которую проползла черепашка (включая начальную и конечную клетку). Найдите наибольшее возможное значение этой суммы и маршрут, на котором достигается эта сумма.
#
# Формат ввода
# В первой строке входных данных записаны два натуральных числа N и M, не превосходящих 100 — размеры таблицы. Далее идет N строк, каждая из которых содержит M чисел, разделенных пробелами — описание таблицы. Все числа в клетках таблицы целые и могут принимать значения от 0 до 100.
# Формат вывода
# Первая строка выходных данных содержит максимальную возможную сумму, вторая — маршрут, на котором достигается эта сумма. Маршрут выводится в виде последовательности, которая должна содержать N-1 букву D, означающую передвижение вниз и M-1 букву R, означающую передвижение направо. Если таких последовательностей несколько, необходимо вывести ровно одну (любую) из них.
# Пример
# Ввод	Вывод
# 5 5
# 9 9 9 9 9
# 3 0 0 0 0
# 9 9 9 9 9
# 6 6 6 6 8
# 9 9 9 9 9
# 74
# D D R R R R D D
import sys
from typing import List, Tuple

def get_path(mat: List[Tuple[int]], n: int, m: int)->str:
    dp = [[0] * n for _ in range(m)]
    dp[0][0] = mat[0][0]
    for i in range(1, n):
        dp[i][0] = dp[i - 1][0] + mat[i][0]
    for j in range(1, m):
        dp[0][j] = mat[0][j] + dp[0][j-1]

    for i in range(1, n):
        for j in range(1, m):
            dp[i][j] = max(dp[i][j-1], dp[i-1][j]) + mat[i][j]
    path = []
    n, m = n-1,m-1
    while n > 0 or m > 0:
        if m > 0 and dp[n-1][m] < dp[n][m - 1]:
            path.append('R')
            m -= 1
        else:
            path.append('D')
            n -= 1
    return f"{dp[n-1][m-1]}\n{' '.join(path)}"

if __name__=='__main__':
    h, w = tuple(map(int,sys.stdin.readline().split()))
    matrix = [tuple(map(int, sys.stdin.readline().split())) for _ in range(h)]
    sys.stdout.write(get_path(matrix, h,w))

